<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>继承--寄生组合式继承</title>
</head>
<body>

</body>
</html>
<script>
    //es5
    //1, 原型式继承: 以一个已有的对象为原型,创造一个新的对象
    function inheritObject(o) {
        function F() {}
        F.prototype=o;
        return new F();
    }
    //2, 寄生式继承: 在原型式继承的基础上, 为新的对象添加新的方法
    function createObj(proto) {
        var o=inheritObject(proto);
        o.getName=function () {
            console.log(name);
        }
        return o;
    }
    //3, 寄生组合式继承: 在子类和父类中间添加一层次,
    //比如该层次的对象为p, p的原型指向父类的原型,子类的原型指向p,
    //p的构造函数指向子类.
    function inheritProto(subClass,superClass) {
        //使用原型继承创建一个父类的子类;
        var middle=inheritObject(superClass);
        //子类的原型指向middle
        subClass.prototype=middle;
        //middle的构造属性指向子类
        middle.constructor=subClass;
    }
    //4,缺陷
    //因为寄生组合继承只是解决了继承链的问题,
    //没有解决实例属性的问题,
    //所以在子类构造函数中,需要用构造函数式继承,解决实例属性继承的问题

    //5, 测试用例
    function SuperClass(name) {
        this.name=name;
        this.colors=['red','blue','green'];
    }
    SuperClass.prototype.showColors=function () {
        console.log(this.colors);
    }
    function SubClass(name,time) {
        SuperClass.call(this,name);
        this.time=time;
    }
    var instance1=new SubClass("sub1","2014");
    var instance2=new SubClass("sub2","2015");

    instance1.colors.push("yellow");
    instance2.colors.push("gray");

    console.log(instance1);
    console.log(instance2);









</script>



