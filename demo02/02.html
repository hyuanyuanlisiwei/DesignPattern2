<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>面向对象编程--继承--类式继承</title>
</head>
<body>
</body>
</html>
<script>
    //es5
    //定义: 让子类的原型指向父类的实例

    //1,声明父类
    function SuperClass() {
        this.superValue=true;
    }
    SuperClass.prototype.getSuperValue=function () {
        return this.superValue;
    }
    //2,声明子类
    function SubClass() {
        this.subValue=false;
    }
    //3,继承父类(关键代码)
    SubClass.prototype=new SuperClass();
    //要改变子类的原型方法,必须放到3后边, 否则改变就被3覆盖了,导致改变无效.
    SubClass.prototype.getSubValue=function () {
        return this.subValue;
    }
    //4, 测试
    var instance=new SubClass();
    console.log(instance.getSuperValue());
    console.log(instance.getSubValue());
    console.log("-------------")

    //5, 导致的问题
    // SubClass.prototype=new SuperClass();
    // 所有的子类实例的原型都是一个父类实例;
    // 如果父类实例属性中,如果有引用类型的属性,
    // 则会导致,如果一个子类实例改变原型对象中的引用属性.
    // 则其他子类也会受到影响.

    //6, 解决办法
    // 把父类的构造函数当成一个普通函数进行调用
    // 则有了构造函数继承
</script>
<script>
    //父类
    class SuperClass2{
        constructor(){
            this.superValue=true;
        }
        getSuperValue(){
            return this.superValue;
        }
    }
    //子类
    class SubClass2 extends SuperClass2{
        constructor(){
            super();
            this.subValue=false;
        }
        getSubValue(){
            return this.subValue;
        }
    }
    let sub=new SubClass2("subclass");
    console.log(sub.getSubValue());
    console.log(sub.getSuperValue());



</script>
